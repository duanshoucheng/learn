# 1、Java虚拟机和Dalvik虚拟机的区别
首先两者不兼容，并且还有明显的不同：
- Java虚拟机运行的是Java字节码，而Dalvik虚拟机运行的则是其专有的文件格式DEX（Dalvik Executable）。
- 在Java SE程序中的Java类会被编译成一个或者多个字节码文件（.class）然后打包到JAR文件，而后Java虚拟机会从相应的CLASS文件和JAR文 件中获取相应的字节码；Android应用虽然也是使用Java语言进行编程，但是在编译成CLASS文件后，还会通过一个工具（dx）将应用所有的 CLASS文件转换成一个DEX文件，而后Dalvik虚拟机会从其中读取指令和数据。

>字节码是一种中间状态（中间码）的二进制代码（文件）。需要直译器转译后才能成为机器码。机器码是机器可以直接读取的代码。C/C++速度快就是因为可以直接把源码翻译成机器码。

Java虚拟机 |  Dalvik虚拟机
---|---
java虚拟机基于栈。基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多 | dalvik虚拟机是基于寄存器的
java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件，打包到.jar文件中，java虚拟机从相应的.class文件和.jar文件中获取相应的字节码） |Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据）
 \ |常量池已被修改为只使用32位的索引，以简化解释器。dalvik的堆和栈的参数可以通过-Xms和-Xmx更改
 \ | 一个应用，一个虚拟机实例，一个进程（所有android应用的线程都是对应一个linux线程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个android dalvik应用程序都被赋予了一个独立的linux PID(app_*)）

Dalvik和标准Java虚拟机（JVM）之间的首要差别之一，就是Dalvik基于寄存器，而JVM基于栈。
Dalvik和Java之间的另外一大区别就是运行环境——Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个 Dalvik应用作为一个独立的Linux进程执行。
1. 虚拟机很小，使用的空间也小；
2. Dalvik没有JIT编译器；
3. 常量池已被修改为只使用32位的索引，以简化解释器；
4. 它使用自己的字节码，而非Java字节码。

 Dalvik进程管理：
dalvik进程管理是依赖于linux的进程体系结构的，如要为应用程序创建一个进程，它会使用linux的fork机制来复制一个进程（复制进程往往比创建进程效率更高）。
Zygote是一个虚拟机进程，同时也是一个虚拟机实例的孵化器，它通过init进程启动。首先会孵化出System_Server（android绝大多系统服务的守护进程，它会监听socket等待请求命令，当有一个应用程序启动时，就会向它发出请求，zygote就会FORK出一个新的应用程序进程）.每当系统要求执行一个android应用程序时，Zygote就会运用linux的FORK进制产生一个子进程来执行该应用程序。

# 2、什么是ART虚拟机，和JVM/DVM有什么不同
首先了解JIT（Just In Time，即时编译技术）和AOT(Ahead Of Time，预编译技术)两种编译模式。

JIT以JVM为例，javac把程序源码编译成JAVA字节码，JVM通过逐条解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译，执行速度必然比（C/C++）编译后的可执行二进制字节码程序慢，为了提高执行速度，就引入了JIT技术，JIT会在运行时分析应用程序的代码，识别哪些方法可以归类为热方法，这些方法会被JIT编译器编译成对应的汇编代码，然后存储到代码缓存中，以后调用这些方法时就不用解释执行了，可以直接使用代码缓存中已编译好的汇编代码。这能显著提升应用程序的执行效率。（安卓Dalvik虚拟机在2.2中增加了JIT）
相对的AOT就是指C/C++这类语言，编译器在编译时直接将程序源码编译成目标机器码，运行时直接运行机器码。

**Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码**

Dalvik执行的是dex字节码，依靠JIT编译器去解释执行，运行时动态地将执行频率很高的dex字节码翻译成本地机器码，然后在执行，但是将dex字节码翻译成本地机器码是发生在应用程序的运行过程中，并且应用程序每一次重新运行的时候，都要重新做这个翻译工作，因此，即使采用了JIT，Dalvik虚拟机的总体性能还是不能与直接执行本地机器码的ART虚拟机相比。

安卓运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者重新将自己的应用直接编译成目标机器码，也就是说，应用程序仍然是一个包含dex字节码的apk文件。所以在安装应用的时候，dex中的字节码将被编译成本地机器码，之后每次打开应用，执行的都是本地机器码。移除了运行时的解释执行，效率更高，启动更快。（安卓在4.4中发布了ART运行时）

两者的功能都是一样的，都是将.class文件转为机器码。

ART优点：
- 系统性能显著提升
- 应用启动更快、运行更快、体验更流畅、触感反馈更及时
- 续航能力提升
- 支持更低的硬件

ART缺点
- 更大的存储空间占用，可能增加10%-20%
- 更长的应用安装时间

总的来说ART就是“空间换时间”

# JVM垃圾收集算法和垃圾收集器
来源：[你不得不了解的JVM（二）](http://www.jianshu.com/p/7c708a66ff42)

垃圾收集算法有：
1. 标记-清除算法
2. 标记-整理算法
3. 复制算法
4. 分代收集算法：当前商业虚拟机基本采用的都是分代收集。结合了复制和标记-整理的优势。一般做法是将Java堆分为新生代和老年代。由于新生代会不断产生新生对象，因此采用了复制算法；而年老代的对象存活率较高，因此采用了标记-整理算法。
在新生代中，我们可以看到新生代=Eden+S0+S1；他们设计的默认比例是8：1：1；这个参数是可以通过虚拟机参数进行调整的。

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。一共是7种收集器
1. Serial/Serial Old
2. ParNew
3. Parallel Scavenge/Parallel Old  
吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；所以垃圾收集时间越短，吞吐量就是越大
4. CMS(Concurrent Mark Sweep)
5. G1